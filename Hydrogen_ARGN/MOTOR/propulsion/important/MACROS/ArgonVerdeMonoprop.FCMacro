# -*- coding:utf-8 -*-
import FreeCAD as App, FreeCADGui as Gui, Part, math

# ---------------- DOCUMENTO ----------------
doc_name = "ArgonLander_DomeExtended_Master"
if App.ActiveDocument is None or App.ActiveDocument.Label != doc_name:
    App.newDocument(doc_name)
doc = App.ActiveDocument

# ---------------- PARÁMETROS ----------------
P = {
    # Cuerpo principal (alargado) y cúpula
    "bus_d": 4400, "bus_len": 6800, "bus_t": 90,
    "dome_R": 2400, "dome_t": 50, "dome_cx_offset": +200,  # cúpula ligeramente adelantada

    # Anillos y refuerzos bajo cúpula
    "crown_ring_d": 4600, "crown_ring_t": 120, "crown_offset": +200,
    "crown_ribs_n": 8, "crown_rib_d": 220, "crown_rib_len": 1400,

    # Tanques esféricos laterales
    "side_tank_R": 1700, "side_tank_offset_y": 3900, "side_tank_cx": +700,

    # Toberas principales
    "main_throat": 980, "main_exit": 2400, "main_len": 2000,
    "main_sep_z": 1600, "main_cx": 3200,

    # Patas y pads
    "leg_n": 4, "leg_len": 3000, "leg_d": 280,
    "leg_base_cx": +200, "leg_base_R": 2400,
    "pad_d": 1800, "pad_t": 140, "pad_drop": 2600,

    # Puntales (struts) intermedios
    "strut_d": 200, "strut_len": 2200,
    "mid_ring_d": 4800, "mid_ring_t": 100, "mid_ring_cx": -800,

    # Bridas/anillos longitudinales
    "flange_n": 6, "flange_d": 4800, "flange_t": 80, "flange_pitch": 700, "flange_x0": -600,

    # Truss externo fino (decorativo, estable)
    "truss_tube_d": 160, "truss_rows": 4, "truss_cols": 12,
    "truss_belt_len": 3200, "truss_belt_cx": 0, "truss_radius_offset": 280,

    # Color mint argón
    "mint": (0.70, 0.95, 0.85), "dark": (0.35, 0.55, 0.50), "accent": (0.55, 0.85, 0.75)
}

# ---------------- UTILIDADES ----------------
X_AXIS = App.Vector(1,0,0); Y_AXIS = App.Vector(0,1,0); Z_AXIS = App.Vector(0,0,1)
def rot_to_x(): return App.Rotation(Y_AXIS, 90)

def add_obj(shape, label, color=None):
    o = doc.addObject("Part::Feature", label); o.Shape = shape
    if color and hasattr(o, "ViewObject"): o.ViewObject.ShapeColor = color
    return o

def is_valid(shape):
    try: return (shape is not None) and (not shape.isNull())
    except: return False

def fuse_many(items):
    seq=[]
    for s in items:
        sh = s.Shape if hasattr(s, "Shape") else s
        if is_valid(sh): seq.append(sh)
    if not seq: return None
    u = seq[0]
    for sh in seq[1:]:
        try: u = u.fuse(sh)
        except: pass
    return u

def cyl_x(d, L, cx=0, cy=0, cz=0):
    c = Part.makeCylinder(d/2.0, L)
    c.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return c

def cone_x(d1, d2, L, cx=0, cy=0, cz=0):
    c = Part.makeCone(d1/2.0, d2/2.0, L)
    c.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return c

def sphere_at(R, cx=0, cy=0, cz=0):
    s = Part.makeSphere(R)
    s.Placement = App.Placement(App.Vector(cx, cy, cz), App.Rotation())
    return s

# ---------------- CUERPO + CÚPULA ----------------
bus_outer = cyl_x(P["bus_d"], P["bus_len"], cx=0)
bus_inner = cyl_x(P["bus_d"] - 2*P["bus_t"], P["bus_len"] - 2*P["bus_t"], cx=0)
bus_shell = bus_outer.cut(bus_inner)

# Cúpula: casquete esférico hueco (hemisferio recortado y aligerado)
dome_center_x = P["bus_len"]/2.0 + P["dome_cx_offset"]
dome_outer = sphere_at(P["dome_R"], cx=dome_center_x)
dome_inner = sphere_at(P["dome_R"] - P["dome_t"], cx=dome_center_x)
cut_box = Part.makeBox(2*P["dome_R"], 4*P["dome_R"], 4*P["dome_R"],
                       App.Vector(dome_center_x, -2*P["dome_R"], -2*P["dome_R"]))
dome_shell = dome_outer.common(cut_box).cut(dome_inner.common(cut_box))

# Anillo de corona bajo la cúpula
crown_ring = cyl_x(P["crown_ring_d"], P["crown_ring_t"],
                   cx=dome_center_x - P["crown_ring_t"]/2.0 + P["crown_offset"])

# Nervios de corona (radiales, cortos)
crown_ribs=[]
for i in range(P["crown_ribs_n"]):
    az = i * (360.0 / P["crown_ribs_n"])
    y = (P["crown_ring_d"]/2.0) * math.cos(math.radians(az))
    z = (P["crown_ring_d"]/2.0) * math.sin(math.radians(az))
    rib = cyl_x(P["crown_rib_d"], P["crown_rib_len"],
                cx=dome_center_x - P["crown_rib_len"]/2.0 + P["crown_offset"],
                cy=y, cz=z)
    crown_ribs.append(rib)

# ---------------- TANQUES ESFÉRICOS LATERALES ----------------
tank_L = sphere_at(P["side_tank_R"], cx=P["side_tank_cx"], cy=-P["side_tank_offset_y"])
tank_R = sphere_at(P["side_tank_R"], cx=P["side_tank_cx"], cy= P["side_tank_offset_y"])

# ---------------- TOBERAS PRINCIPALES ----------------
nozz_1 = cone_x(P["main_throat"], P["main_exit"], P["main_len"],
                cx=P["main_cx"], cz= P["main_sep_z"])
nozz_2 = cone_x(P["main_throat"], P["main_exit"], P["main_len"],
                cx=P["main_cx"], cz=-P["main_sep_z"])

# ---------------- PATAS (4) Y PADS ----------------
legs=[]; pads=[]
for i in range(P["leg_n"]):
    az = i * (360.0 / P["leg_n"])
    y = P["leg_base_R"] * math.cos(math.radians(az))
    z = P["leg_base_R"] * math.sin(math.radians(az))
    # Viga de la pata
    leg = cyl_x(P["leg_d"], P["leg_len"], cx=P["leg_base_cx"], cy=y*0.98, cz=z*0.98)
    legs.append(leg)
    # Pad
    pad = cyl_x(P["pad_d"], P["pad_t"], cx=P["leg_base_cx"] - P["pad_drop"], cy=y, cz=z)
    pads.append(pad)

# ---------------- PUNTALES INTERMEDIOS + ANILLO MEDIO ----------------
mid_ring = cyl_x(P["mid_ring_d"], P["mid_ring_t"], cx=P["mid_ring_cx"])
struts=[]
for side in [-1, 1]:
    for k in range(6):
        az = k * (360.0 / 6)
        y = (P["bus_d"]/2.0 + 500) * math.cos(math.radians(az)) * side
        z = (P["bus_d"]/2.0 + 500) * math.sin(math.radians(az))
        s = cyl_x(P["strut_d"], P["strut_len"], cx=P["mid_ring_cx"] + 300, cy=y, cz=z)
        struts.append(s)

# ---------------- BRIDAS / ANILLOS LONGITUDINALES ----------------
flanges=[]
for i in range(P["flange_n"]):
    x = P["flange_x0"] + i * P["flange_pitch"]
    fl = cyl_x(P["flange_d"], P["flange_t"], cx=x)
    flanges.append(fl)

# ---------------- TRUSS EXTERNO FINO ----------------
truss=[]
belt_x0 = P["truss_belt_cx"] - P["truss_belt_len"]/2.0
belt_x1 = P["truss_belt_cx"] + P["truss_belt_len"]/2.0
row_gap = (belt_x1 - belt_x0) / (P["truss_rows"] + 1)
radius_truss = P["bus_d"]/2.0 + P["truss_radius_offset"]

for r in range(P["truss_rows"]):
    cx = belt_x0 + (r+1)*row_gap
    for c in range(P["truss_cols"]):
        az = c * (360.0 / P["truss_cols"])
        y = radius_truss * math.cos(math.radians(az))
        z = radius_truss * math.sin(math.radians(az))
        tube = cyl_x(P["truss_tube_d"], 280, cx=cx, cy=y, cz=z)
        truss.append(tube)

# ---------------- ENSAMBLAJE EN SÓLIDO ÚNICO ----------------
items = [
    bus_shell, dome_shell, crown_ring, mid_ring,
    tank_L, tank_R, nozz_1, nozz_2
] + crown_ribs + legs + pads + struts + flanges + truss

master = fuse_many(items)
master_obj = add_obj(master, "ArgonLander_DomeExtended_MasterSolid", color=P["mint"])

# ---------------- VISUAL AUXILIAR ----------------
add_obj(bus_shell, "BusShell", color=P["accent"])
add_obj(dome_shell, "DomeShell", color=P["accent"])
add_obj(crown_ring, "CrownRing", color=P["accent"])
add_obj(mid_ring, "MidRing", color=P["accent"])
add_obj(tank_L, "SideTank_L", color=P["mint"])
add_obj(tank_R, "SideTank_R", color=P["mint"])
add_obj(nozz_1, "MainNozzle_1", color=P["dark"])
add_obj(nozz_2, "MainNozzle_2", color=P["dark"])
for i, rb in enumerate(crown_ribs, 1): add_obj(rb, f"CrownRib_{i}", color=P["accent"])
for i, lg in enumerate(legs, 1): add_obj(lg, f"Leg_{i}", color=P["accent"])
for i, pd in enumerate(pads, 1): add_obj(pd, f"Pad_{i}", color=P["accent"])
for i, st in enumerate(struts, 1): add_obj(st, f"Strut_{i}", color=P["accent"])
for i, fl in enumerate(flanges, 1): add_obj(fl, f"Flange_{i}", color=P["accent"])
for i, tr in enumerate(truss, 1): add_obj(tr, f"Truss_{i}", color=P["accent"])

# ---------------- VISTA ----------------
doc.recompute()
try:
    Gui.ActiveDocument.ActiveView.viewAxonometric()
    Gui.SendMsgToActiveView("ViewFit")
except:
    pass
