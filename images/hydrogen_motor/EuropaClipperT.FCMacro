# -*- coding: utf-8 -*-
# Macro FreeCAD: Europa Clipper - Ensamblado Paramétrico (eje X)
# Autor: Víctor + Copilot
# Unidades: mm, eje = X

import FreeCAD as App, FreeCADGui as Gui, Part, math

DOC_NAME = "Europa_Clipper_X"
if App.ActiveDocument is None or App.ActiveDocument.Label != DOC_NAME:
    App.newDocument(DOC_NAME)
doc = App.ActiveDocument

# ========================
# Parámetros (mm)
# ========================
P = {
    # Bus cilíndrico (altura a lo largo del eje X)
    "bus_D": 3120.0,      # diámetro
    "bus_L": 3630.0,      # longitud (altura real) en X

    # Frustum base (bajo el bus, continúa a lo largo de X hacia -X)
    "frustum_Rtop": 1560.0,  # radio superior (≈ bus_D/2)
    "frustum_Rbot": 1700.0,  # radio inferior
    "frustum_L": 2088.0,     # longitud (altura frustum) en X
    "frustum_gap": 40.0,     # pequeño solape/holgura con el bus

    # Tanques laterales (2 uds, verticales respecto al bus; longitud en X)
    "tank_D": 940.0,
    "tank_L": 2490.0,
    "tank_offY": 1600.0,   # separación lateral Y desde el eje
    "tank_offZ": 0.0,      # elevación Z respecto al centro del bus
    "tank_cx": 0.0,        # centro X de los tanques (ajústalo para posición exacta)

    # Antena de alta ganancia (HGA) ~ calota esférica
    "hga_D": 3000.0,
    "hga_depth": 500.0,    # profundidad de la calota
    "hga_offX": 1200.0,    # desplazamiento X desde el centro del bus
    "hga_offY": 2000.0,    # desplazamiento Y
    "hga_offZ": 600.0,     # desplazamiento Z (altura relativa)

    # Paneles solares (cada ala)
    "panel_L": 14200.0,    # longitud en X
    "panel_T": 40.0,       # espesor en Y
    "panel_H": 4100.0,     # altura en Z
    "panel_hinge_X": 500.0, # posición X de la bisagra respecto al centro del bus
    "panel_gap_Y": 300.0,  # separación desde el bus en Y

    # Boom magnetómetro
    "boom_L": 8500.0,
    "boom_D": 80.0,
    "boom_offX": 1200.0,
    "boom_offY": 2000.0,
    "boom_offZ": (3120.0/2.0) - 300.0,  # cerca del “borde superior” del bus

    # Base/plataforma (opcional, para contexto)
    "pad_W": 5000.0, "pad_D": 5000.0, "pad_T": 120.0,
    "leg_D": 160.0, "leg_L": 1200.0, "leg_off": 1800.0,
}

# ========================
# Utilidades (eje X)
# ========================
X_AXIS = App.Vector(1,0,0)
Y_AXIS = App.Vector(0,1,0)
Z_AXIS = App.Vector(0,0,1)

def rot_to_x():
    return App.Rotation(Y_AXIS, 90)

def add_obj(shape, label):
    obj = doc.addObject("Part::Feature", label)
    obj.Shape = shape
    return obj

def make_cyl_x(d, L, cx=0.0, cy=0.0, cz=0.0, label="CylX"):
    r = d/2.0
    cyl = Part.makeCylinder(r, L)
    cyl.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cyl, label)

def make_cone_x(d1, d2, L, cx=0.0, cy=0.0, cz=0.0, label="ConeX"):
    r1, r2 = d1/2.0, d2/2.0
    cone = Part.makeCone(r1, r2, L)
    cone.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cone, label)

def make_box(w, d, h, cx=0.0, cy=0.0, cz=0.0, label="Box"):
    b = Part.makeBox(w, d, h)
    b.Placement = App.Placement(App.Vector(cx - w/2.0, cy - d/2.0, cz - h/2.0), App.Rotation())
    return add_obj(b, label)

def make_spherical_cap(D, depth, cx=0.0, cy=0.0, cz=0.0, label="HGA_Cap"):
    R = D/2.0
    sph = Part.makeSphere(R)
    # Cortamos con una caja para crear calota
    cut = Part.makeBox(2*R, 2*R, depth)
    cut.Placement = App.Placement(App.Vector(-R, -R, -depth), App.Rotation())
    cap = sph.cut(cut)
    cap.translate(App.Vector(cx, cy, cz))
    return add_obj(cap, label)

# ========================
# Base / plataforma (opcional)
# ========================
pad = make_box(P["pad_W"], P["pad_D"], P["pad_T"], cx=0.0, cy=0.0, cz=-(P["pad_T"]/2.0), label="Base_Pad")
legs = []
for sx in [-P["leg_off"], P["leg_off"]]:
    for sy in [-P["leg_off"], P["leg_off"]]:
        leg = Part.makeCylinder(P["leg_D"]/2.0, P["leg_L"])
        leg.Placement = App.Placement(App.Vector(sx, sy, -P["pad_T"]/2.0), App.Rotation())
        legs.append(leg)
legs_union = legs[0].fuse(legs[1]).fuse(legs[2]).fuse(legs[3])
add_obj(legs_union, "Base_Legs")

# ========================
# Bus cilíndrico (principal)
# ========================
bus = make_cyl_x(P["bus_D"], P["bus_L"], cx=0.0, cy=0.0, cz=0.0, label="Bus")

# ========================
# Frustum inferior (con leve solape)
# ========================
frustum_cx = - (P["bus_L"]/2.0) - (P["frustum_L"]/2.0) + P["frustum_gap"]
frustum = make_cone_x(2.0 * P["frustum_Rtop"], 2.0 * P["frustum_Rbot"], P["frustum_L"],
                      cx=frustum_cx, cy=0.0, cz=0.0, label="Frustum")

# ========================
# Tanques laterales (simétricos en Y)
# ========================
tank_cx = P["tank_cx"]
tankL = make_cyl_x(P["tank_D"], P["tank_L"], cx=tank_cx, cy= P["tank_offY"], cz=P["tank_offZ"], label="Tank_Left")
tankR = make_cyl_x(P["tank_D"], P["tank_L"], cx=tank_cx, cy=-P["tank_offY"], cz=P["tank_offZ"], label="Tank_Right")

# ========================
# Antena HGA (calota)
# ========================
hga = make_spherical_cap(P["hga_D"], P["hga_depth"], cx=P["hga_offX"], cy=P["hga_offY"], cz=P["hga_offZ"], label="HGA")

# ========================
# Paneles solares (alas)
# ========================
# Panel izquierdo: se extiende hacia +X desde la bisagra
panelL = make_box(P["panel_L"], P["panel_T"], P["panel_H"],
                  cx=P["panel_hinge_X"] + P["panel_L"]/2.0,
                  cy= P["panel_gap_Y"] + P["bus_D"]/2.0 + P["panel_T"]/2.0,
                  cz=0.0,
                  label="Panel_Left")
# Panel derecho: simétrico hacia -X
panelR = make_box(P["panel_L"], P["panel_T"], P["panel_H"],
                  cx=-P["panel_hinge_X"] - P["panel_L"]/2.0,
                  cy= -P["panel_gap_Y"] - P["bus_D"]/2.0 - P["panel_T"]/2.0,
                  cz=0.0,
                  label="Panel_Right")

# ========================
# Boom magnetómetro
# ========================
boom = make_cyl_x(P["boom_D"], P["boom_L"],
                  cx=P["boom_offX"], cy=P["boom_offY"], cz=P["boom_offZ"],
                  label="Boom_Magnetometer")

# ========================
# Vista y recompute
# ========================
doc.recompute()
try:
    Gui.ActiveDocument.ActiveView.viewAxonometric()
    Gui.SendMsgToActiveView("ViewFit")
except:
    pass

print("Europa Clipper creado en '{}' con ensamblado eje X y módulos independientes.".format(doc.Label))
